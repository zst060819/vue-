/**
 * 
 * 
 * 1.对象的理解----帮助我们更好的书写代码以及培养面向对象的编程思想
 * 
 *  1)什么是对象: 看得见或者是摸得到,特指的某个东西
 *   车--->大的概念  不是对象---所有车的类别
 *   我家楼下门口的这辆白色的车-----对象---特指
 *   电脑----大的概念,不是对象---所有电脑的类别
 *   我的这台电脑---对象---特指的某个东西
 *   班主任----大的概念---所有班主任的类别
 *   我们班的班主任----对象
 * 
 *   通过文字的描述----来分析出对象
 * 
 *  观察图片,观察周围的事物---区分对象
 *  通过观察图片,
 *  结论: 对象都有特征和行为
 *  观察周围
 *  桌子----对象
 *  特征: 重量,颜色,尺寸
 *  行为: 载物
 * 
 * 什么是对象?
 *  具有特征或者行为,特指的某个事物
 * 通过观察对象,分析出对象应该有的特性和行为
 * 把观察到的对象,变成代码的方式来体现出来
 * 
 * 编程的思想:
 * 面向过程编程: 每一步都要亲力亲为,凡事只是注重过程,
 * 计算两个数字的和,代码都要自己写
 * 需求:我饿了,自己做饭,刷锅,放油,炒菜,煮米饭,装盘,自己吃-----每一步都要自己做
 * 
 * 面向对象编程: 只需要找到对象,得到结果,注重的是结果
 * 计算两个数字的和,找到对象,对象可以调用方法(计算),得到结果
 * 需求:我饿了,找对象,对象做饭,自己只是提出需求,最终饭好了.吃即可
 * 
 * 何为面向对象的编程思想；
 * 通过观察,找到对象,分析对象中的特征和行为,抽象出对应的特征和行为,把特征换一个叫法,叫属性,行为换一个叫法,叫方法
 * 书写代码的时候,先定义对象的类型----类(类别)---构造函数,内部准备好属性及方法,创建对象---实例化对象(初始化对象)
 * 通过对象调用相关的方法,从而实现面向对象的编程思想
 * 实例化---创建对象
 * 实例化并初始化---创建对象的同时初始化内部的属性的值
 * 
 * 对象中 属性和方法
 * 
 * 
 * 
 * 
 * 
 * 2.组件的理解-----项目熟练的使用组件及拆分组件
 * 为什么要有组件?开发起来更加方便,多人协作开发,没有问题,同时实现了页面的拆分效果,实现了渐进式的方式
 * 
 * 组件:具有特定功能效果的集合
 * 
 * 
 * 
 * 
 * 
 * 3.路由的不同传参方式----项目熟练使用路由传参
 * (前端)路由: 一种映射关系,地址对应着组件,是一种键值对的写法,键:地址,值:组件,形成了 访问某个地址,就会显示某个组件内容
 * 
 * 为什么要有路由:通过路由可以实现单页面应用,SPA
 * 地址发生了变化,页面中的效果就会跟着变化----这种效果---路由的跳转
 * 一个地址对应着一个组件(每个组件显示的内容不同)
 * a地址---A组件----首页
 * b地址---B组件----详情页
 * c地址---C组件----底部
 * 进入到了a的地址---->就会显示首页内容
 * 
 * 地址和组件之间有一种映射关系
 * 如果一个普通的组件已经注册了(地址和组件已经形成了映射关系),此时该组件就已经是一个路由组件了
 * 上面的这个操作,叫路由的注册---->注册路由(地址和组件已经形成了映射关系)
 *  当前的这个组件的对象中 就多了一个东西: $router---->路由器对象,可以调用方法实现路由的跳转
 *  当前的这个组件的对象中 就多了一个东西: $route---->路由信息对象, 可以调用params,query,meata属性获取路由跳转的时候传递的相关的参数数据
 * 
 * 
 * 
 * 路由为什么要传参: 通过传参---传递数据,根据数据不同,可以实现相对应的功能
 * 
 * 
 * 
 * 4.数组中的常用方法----项目中熟练的使用相关的方法,从而让编程更加快(减少冗余代码量)
 * 
 * 
 * 5.请求拦截器和响应拦截器----必会的内容
 * 
 */
// 面向过程
//  function cook (){
//    console.log('煮米饭')
//    console.log('洗菜')
//    console.log('炒菜')
//    console.log('放油')
//    console.log('装盘')
//  }
//  cook() // 吃饭了

// 面向对象
//  var obj = new GirlFriend()
//  obj.cook()


// function Person(name,age,gender){
//   // 特征---属性
//  this.name=name
//  this.age=age
//  this.gender=gender
//   // 行为---方法
//   this.eat=function(){
//     console.log('好吃')
//   }
// }

// var p1 = new Person()  // 实例化
// var p2 = new Person('小明',10,'男') // 实例化并初始化
// p1.eat()  // 方法的调用---行为的体现

// 需求: 遍历一些 数据----面向过程的写法
// var arr = [10, 20, 30, 40, 50]
// for (var i = 0; i < arr.length; i++) {
//   console.log(arr[i])
// }
// // 面向对象的写法
// [10, 20, 30, 40].forEach(item => {
//   console.log(item)
// })

// 小明给小红打电话---面向对象的编程思想
function Person (name) {
  this.name = name
}
// 打电话
Person.prototype.callPhone = function () {
  console.log('打电话')
}
// 接电话
Person.prototype.listenerPhone = function () {
  console.log('接电话')
}
var p1 = new Person('小明')
var p2 = new Person('小红')
p1.callPhone() // 打电话
p2.listenerPhone() // 接听电话

function Vue (options) {
  this.options = options
  var data = this._data = options.data || {}
  // 遍历data对象中所有的key
  Object.keys(data).forEach(key => {
    // 实现数据代理
    this._proxyData(key)
  })
}

Vue.prototype.watch = function () {
  console.log('监视了')
}
var vm = new Vue({
  el: '#app',
  data () {
    return {
      age: 20
    }
  }
})

vm.watch() // 调用该方法
