/*

1. 启动项目:  npm run dev
2. 项目初次运行,直接报错,需要运行:npm rebuild node-sass   (部分同学不会报错,不需要运行这个命令)
3. 需要更改当前项目的服务器地址
  1) vue.config.js  第45行   http://182.92.128.115
  2) src/utils/request.js 第10行 http://182.92.128.115
  3) .env.development文件 第6行 http://182.92.128.115
4. 项目启动后,在浏览器中使用了两个tab打开的界面(直接打开了两个界面),解决:
  1) 先在 vue.config.js 文件中  第37行  open: false 不在浏览器中打开
  2) 然后在package.json文件中 第8行  "dev": "vue-cli-service serve --open", 可以在浏览器中自动的打开了

5. 如果希望打开项目后,地址栏中没有#,去src/router/index.js中 第69行, 设置为 mode: 'history'
6. 在src/views/product/prop目录--->prop改成attr 重启项目

=========以上是旧版的改造过程=============

==========新版==========无需改造=========

1. 项目技术栈: vue-cli3+element-ui组件库+vuex+axios+swagger在线api接口测试工具
2. 当前项目是属于二次开发的项目,并不是从0到1
3. 项目目录说明，src目录下:
  api目录:存放api接口函数的目录(内部有不同模块的api接口函数)
  assets目录:存放静态资源的
  components目录:普通组件
  icons:图标
  layout目录:整体的结构搭建的部分组件
  plugins目录:插件的
  router目录:路由
  store目录:vuex
  styles目录:样式
  utils目录:工具方面的文件,如:axios的二次封装,请求拦截器和响应拦截器,表单验证的东西
  views目录:各个模块的组件
    product目录---我们要开发的目录

  api目录和views目录中product目录---经常使用---进行开发




=======================平台管理模块==============
1. 需要使用到的组件:
  Button按钮/Table表格/Pagination分页组件/Dialog对话框/Upload上传Loading组件

2. 
  1) 首先通过Swagger在线测试接口工具,进行接口的测试
  2) 在api目录/product目录/trademark.js文件 封装各个接口函数
  3) 在api目录/index.js文件中 导入 并 导出 trademark模块
  4) src/views/product/trademark/list.vue中mounted中测试接口







  组件之间通信高级内容
  1. 原生事件和自定义事件
  针对的是:组件和HTML标签而言:
  原生事件:DOM中系统自带的事件,如果组件中使用了系统自带的事件,并且使用了.native修饰了
  自定义事件:自己定义的事件(系统中是没有的),针对组件说的

  原生事件:只要事件触发了,回调函数就会自动的调用
  自定义事件:该事件需要手动分发,对应的回调函数才能调用

  总结:
  1)原生事件和自定义事件主要是针对组件而言,HTML标签中只能使用原生事件,不能使用自定义事件
  2)组件中绑定的事件,最终是给了组件中的最外层的根元素标签
  原生事件:组件中使用了系统的事件,但是需要使用.native进行修饰
  自定义事件:自己定义的或者组件中使用了系统自带的事件,但是没有使用.native修饰

  2. v-model的本质:value属性配合input事件
  父级组件可以直接向子级组件中使用v-model指令来实现父子组件通信
  原理:v-model指令在组件中使用的时候,无非就是把value属性和input自定义事件传入到了子级组件中,
  子级组件使用props进行接收(接收的是value属性),可以在子级组件内部通过$emit()分发父级组件传递过来input事件,从而实现父子组件之间通信


  3. .sync修饰符:实现父子组件之间的通信,父级组件向子级组件内部传递一个动态数据,子级组件内部修改该数据后,
  把该数据再传递给父级组件(子级内部的实现原理,先接收父级组件传递过来的数据,然后分发update事件,修改数据,修改后的数据重新传递父级组件)


  4. 
  $attrs:父级组件向子级组件中传递的所有的属性的集合的对象(prop接收的除外,class和style除外)
  $listeners:父级组件向子级组件中传递的所有的事件的集合的对象(.native修饰的除外)
  v-bind:---> 可以直接接收一个对象(该对象中是属性和值的集合的对象) 
  v-on:---->可以直接接收一个对象(该对象中是事件和回调函数的集合的对象)
  通过$attrs和$listeners可以实现父子组件的通信

  5.
  $parent和$children 可以实现父子组件的通信


  6. 混入:把多个组件中共同的选项抽取出来放在一个js文件中,在组件中通过引入的方式设置mixins


  7.
  插槽:
   普通插槽(默认插槽):没有名字,直接使用,父子组件通信
   具名插槽:有名字,使用的时候需要带name,父子组件通信
   作用域插槽:也是插槽,可以向插槽内部传递整块的内容(父子通信,子父通信)
   父级组件向子级组件传递数据,子级组件内部使用slot传入动态数据,父级组件中可以使用子级组件传递过来的动态的数据



  组件通信:
  props: 父子通信
  自定义事件:父子通信
  全局事件总线:任意组件通信
  PubSub:任意组件通信(React一样),不属于Vue
  Vuex:任意组件通信
  插槽(普通插槽,具名插槽,作用域插槽):父子组件通信
  原生事件:父子通信
  v-model:父子通信
  .sync:父子通信
  $parent和$children:父子通信
  $attrs和$listeners:父子通信


*/