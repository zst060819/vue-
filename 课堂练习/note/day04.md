## 今日任务: 实现Search组件
    1)复杂的查询参数准备
    2)响应式数据对象: 添加新属性与删除属性的问题
    3)query参数与params参数的控制(添加/删除/携带)
    4)全局事件总线进行任意组件间通信, vue自定义事件进行子向父通信
    5)切换排序方式的逻辑处理
    6)自定义分页组件

### 搜索条件参数分析
		category1Id:  一级分类ID
		category2Id:  二级分类ID
		category3Id:  三级分类ID
		categoryName: 分类名称
		keyword:     搜索关键字
		trademark:   品牌ID:品牌名称
		order:       排序方式  综合1,价格2 升序asc,降序desc"2:desc"
		pageNo:      当前第几页
		pageSize:    每页最多显示多少条数据	
		props: 		 多个属性条件组件的数组[‘属性ID:属性值:属性名’]
				[
					"2:6.65-6.74英寸:屏幕尺寸",
					"4:16GB:机身存储"
				]
				理解: 商品属性包含: 属性id, 属性名, 多个属性值的数组 

### ajax + vuex

### 在组件中动态显示: 品牌列表 + 属性列表 + 商品列表

### 根据分类和关键字进行搜索
		基本实现
			1). 分类搜索参数: query参数 categoryName / category1Id / category2Id / category3Id
			2). 关键字搜索参数: params参数 keyword
			3). Search组件得到分类/关键字参数并发搜索请求
				mounted() 中处理     从首页跳转到搜索
				watch ==> $route()   在搜索页改变分类或关键字
				利用...合并多个参数数据
		功能bug: 
			问题1描述:
				在搜索页面, 再改变分类或改变关键时, 参数携带有问题
				本来有分类条件 ==> 指定关键字条件  ==> 分类条件就会丢失
				本来有关键字条件 ==> 指定分类条件 ==> 关键字条件就会丢失
			原因:
				根据分类跳转时, 没有携带包含keyword的params参数
				根据关键字进行跳转时, 没有携带包含分类数据的query参数
			解决办法
				1). 判断是在搜索界面
				2). 指定需要携带params或者query参数
				3). 指定replace的跳转方式
				
			问题2描述:
				切换到另一个级别的分类, 原分类的id数据依然还在
			原因:
				没有去重置分类条件数据
			解决:
				在$route的监视回调中, 重置options中的分类相关数据

		删除分类/关键字条件
			问题1. : 地址栏的参数没有同步变化?
			解决: 通过replace()重新跳转到当前搜索界面, 去除params或者query参数
		
		问题: 删除关键字条件时, Header中的关键输入没有清除
		原因: 输入的数据没有做清除处理
		解决: 使用全局事件总线$bus来实现Search组件与Header组件间通信

### 品牌条件的设置与删除
		品牌条件数据的结构: 品牌id:品牌名称
		父子组件间通信
				父向子: 传递一般(非函数)属性
				子向父: 传递函数属性

### 属性条件的添加与删除
		防止添加重复的属性条件


### 排序方式的动态显示与切换
		排序条件数据的结构:
				order: '1:desc'  综合降序
				order: '1:asc'  综合升序
				order: '2:desc'  价格降序
				order: '2:asc'  价格升序
		确定哪个排序项需要选中?
				:class="{active: isActive ('1') }"
		点击切换排序?
				切换排序项: 综合/价格    如果当前排序标记不等于指定的标记
				切换排序方式: 升序/降序  如果当前排序标记等于指定的标记
		动态显示排序方式图标?
				不需要显示   如果当前排序标记不等于指定的标记
				显示升/降的图标   如果当前排序标记等于指定的标记


## 响应式数据对象: 添加新属性与删除属性的问题
		options就是响应式对象

### 给响应式对象添加新的属性
		错误的方式: 直接添加
				this.options.trademark = id + ':' + name
		原因:
				响应式对象直接添加的新属性, 内部是没有监视/劫持的 ==> 没有数据绑定效果
		正确的方式: 通过Vue的set()/$set()来添加新属性
				// 为响应式对象添加一个属性，确保新属性也是响应式的，并且能够触发视图更新
				vm.$set( options, 'trademark', id + ':' + name )
				Vue.set( options, 'trademark', id + ':' + name  )

### 删除已有属性
		问题: delete 删除已有属性不会触发界面更新   setter可以监视属性的改变, 但不能监视属性的移除
		解决: 使用vue提供的delete()/$delete()来删除已有属性
				vm.$delete( options, 'trademark')
				Vue.delete( options, 'trademark')

### 优化搜索请求
		问题: 搜索请求携带了一些没有必要的空串参数
		解决: 在发请求前, 找出空串参数属性进行删除